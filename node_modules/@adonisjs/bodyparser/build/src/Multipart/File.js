"use strict";
/*
 * @adonisjs/bodyparser
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = void 0;
/// <reference path="../../adonis-typings/bodyparser.ts" />
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const utils_1 = require("@poppinss/utils");
const Size_1 = require("./Validators/Size");
const Extensions_1 = require("./Validators/Extensions");
/**
 * The file holds the meta/data for an uploaded file, along with
 * an errors occurred during the upload process.
 */
class File {
    constructor(data, validationOptions) {
        this.data = data;
        this.sizeValidator = new Size_1.SizeValidator(this);
        this.extensionValidator = new Extensions_1.ExtensionValidator(this);
        /**
         * A boolean to know if file is an instance of this class
         * or not
         */
        this.isMultipartFile = true;
        /**
         * Field name is the name of the field
         */
        this.fieldName = this.data.fieldName;
        /**
         * Client name is the file name on the user client
         */
        this.clientName = this.data.clientName;
        /**
         * The headers sent as part of the multipart request
         */
        this.headers = this.data.headers;
        /**
         * File size in bytes
         */
        this.size = 0;
        /**
         * Upload errors
         */
        this.errors = [];
        /**
         * The file meta data
         */
        this.meta = {};
        /**
         * The state of the file
         */
        this.state = 'idle';
        this.sizeLimit = validationOptions.size;
        this.allowedExtensions = validationOptions.extnames;
    }
    /**
     * Whether or not the validations have been executed
     */
    get validated() {
        return this.sizeValidator.validated && this.extensionValidator.validated;
    }
    /**
     * A boolean to know if file has one or more errors
     */
    get isValid() {
        return this.errors.length === 0;
    }
    /**
     * Opposite of [[this.isValid]]
     */
    get hasErrors() {
        return !this.isValid;
    }
    /**
     * The maximum file size limit
     */
    get sizeLimit() {
        return this.sizeValidator.maxLimit;
    }
    set sizeLimit(limit) {
        this.sizeValidator.maxLimit = limit;
    }
    /**
     * Extensions allowed
     */
    get allowedExtensions() {
        return this.extensionValidator.extensions;
    }
    set allowedExtensions(extensions) {
        this.extensionValidator.extensions = extensions;
    }
    /**
     * Validate the file
     */
    validate() {
        this.extensionValidator.validate();
        this.sizeValidator.validate();
    }
    /**
     * Moves the file to a given location. Multiple calls to the `move` method are allowed,
     * incase you want to move a file to multiple locations.
     */
    async move(location, options) {
        if (!this.tmpPath) {
            throw new utils_1.Exception('tmpPath must be set on the file before moving it', 500, 'E_MISSING_FILE_TMP_PATH');
        }
        options = Object.assign({ name: this.clientName, overwrite: true }, options);
        const filePath = path_1.join(location, options.name);
        try {
            await fs_extra_1.move(this.tmpPath, filePath, { overwrite: options.overwrite });
            this.filePath = filePath;
            this.fileName = options.name;
            this.state = 'moved';
        }
        catch (error) {
            if (error.message.includes('dest already exists')) {
                throw new utils_1.Exception(`"${options.name}" already exists at "${location}". Set "overwrite = true" to overwrite it`, 500);
            }
            throw error;
        }
    }
    /**
     * Returns file JSON representation
     */
    toJSON() {
        return {
            fieldName: this.fieldName,
            clientName: this.clientName,
            size: this.size,
            filePath: this.filePath,
            fileName: this.fileName,
            type: this.type,
            extname: this.extname,
            subtype: this.subtype,
            state: this.state,
            isValid: this.isValid,
            validated: this.validated,
            errors: this.errors,
            meta: this.meta,
        };
    }
}
exports.File = File;
