"use strict";
/*
 * @adonisjs/fold
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Injector = void 0;
const helpers_1 = require("../helpers");
const InvalidInjectionException_1 = require("../Exceptions/InvalidInjectionException");
/**
 * Exposes the API to injecting dependencies to a class or a method
 */
class Injector {
    constructor(container) {
        this.container = container;
    }
    /**
     * Resolves the injections to be injected to a method or the
     * class constructor
     */
    resolveInjections(targetName, injections, runtimeValues) {
        /**
         * If the runtime values length is greater or same as the length
         * of injections, then we treat them as the source of truth
         * and inject them as it is
         */
        if (runtimeValues.length >= injections.length) {
            return runtimeValues;
        }
        /**
         * Loop over all the injections and give preference to runtime value
         * for a given index, otherwise fallback to `container.make`.
         */
        return injections.map((injection, index) => {
            if (runtimeValues && runtimeValues[index] !== undefined) {
                return runtimeValues[index];
            }
            /**
             * Disallow object and primitive constructors
             */
            if (helpers_1.isPrimtiveConstructor(injection)) {
                throw InvalidInjectionException_1.InvalidInjectionException.invoke(injections[index], targetName, index);
            }
            return this.container.make(injection);
        });
    }
    /**
     * Injects dependencies to the constructor of a class.
     */
    injectConstructorDependencies(target, runtimeValues) {
        if (!helpers_1.isClass(target) || target.makePlain === true) {
            return target;
        }
        const injections = target.hasOwnProperty('inject') ? target.inject.instance || [] : [];
        return new target(...this.resolveInjections(target.name, injections, runtimeValues));
    }
    /**
     * Injects dependencies to the constructor of a class.
     */
    injectMethodDependencies(target, method, runtimeValues) {
        const constructor = target.constructor;
        const injections = constructor && constructor.hasOwnProperty('inject') ? constructor.inject[method] || [] : [];
        return target[method](...this.resolveInjections(`${constructor.name}.${method}`, injections, runtimeValues));
    }
}
exports.Injector = Injector;
