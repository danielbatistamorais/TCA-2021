import { LookupNode, IocContract, BindCallback, InferMakeType, BindFakeCallback, ExtractFunctions } from '../Contracts';
import { IocResolver } from '../Resolver';
export declare class Ioc implements IocContract {
    /**
     * Find if proxies are enabled or not
     */
    private proxiesEnabled;
    /**
     * A custom method to trap `ioc.use` and `ioc.make` statements
     */
    private trapCallback;
    /**
     * Injector is used for injecting dependencies to the class constructor
     * and the methods
     */
    private injector;
    /**
     * Options passed to the proxy handlers for resolving fakes
     */
    private proxyOptions;
    /**
     * An object of registered bindings
     */
    private bindings;
    /**
     * A Map of registered fakes
     */
    private fakes;
    /**
     * Aliases cache improves the `require` speed, which is dog slow otherwise.
     */
    private aliasesImportCache;
    /**
     * Directories registered with an alias
     */
    directoryAliases: {
        [alias: string]: string;
    };
    /**
     * Method to raise exception when Ioc Container look fails
     */
    onLookupFailed: (namespace: string) => never;
    /**
     * Returns the binding return value. This method must be called when
     * [[hasBinding]] returns true.
     */
    private resolveBinding;
    /**
     * Load a file from the disk using Node.js require method. The output of
     * require is further cached to improve the peformance.
     *
     * Make sure to call this method when [[isAliasPath]] returns true.
     */
    private resolveAlias;
    /**
     * Removes the cache for an alias path. Optionally you can remove
     * the require cache as well
     */
    private removeAliasImportCache;
    /**
     * Wraps object and class to a proxy for enabling the fakes
     * API
     */
    private wrapAsProxy;
    /**
     * Returns a boolean telling if value is a lookup node or not
     */
    private isLookupNode;
    /**
     * Instruct IoC container to use proxies when returning
     * bindings from `use` and `make` methods.
     */
    useProxies(enable?: boolean): this;
    /**
     * Add a new binding with a namespace. Keeping the namespace unique
     * is the responsibility of the user. We do not restrict duplicate
     * namespaces, since it's perfectly acceptable to provide new
     * implementation for an existing binding.
     *
     * @example
     * ```js
     * ioc.bind('App/User', function () {
     *  return new User()
     * })
     * ```
     */
    bind(namespace: string, callback: BindCallback<unknown, this>): this;
    /**
     * Add a new binding as a singleton. This method behaves similar to
     * [[bind]], just the value is cached after the first use. The
     * `callback` will be invoked only once.
     *
     * @example
     * ```js
     * ioc.singleton('App/User', function () {
     *  return new User()
     * })
     * ```
     */
    singleton(namespace: string, callback: BindCallback<unknown, this>): this;
    /**
     * Register a fake for an existing binding. The fakes only work when
     * [[this.useProxies]] is invoked. AdonisJS will invoke it
     * automatically when running tests.
     *
     * NOTE: The return value of fakes is always cached, since multiple
     * calls to `use` after that should points to a same return value.
     *
     * @example
     * ```js
     * ioc.fake('App/User', function () {
     *  return new FakeUser()
     * })
     * ```
     */
    fake(namespace: string, callback: BindFakeCallback<unknown, this>): this;
    /**
     * Define an alias for an existing directory and require
     * files without fighting with relative paths.
     *
     * Given the following directory structure
     *
     * ```sh
     * .app/
     * ├── controllers
     * │   └── foo.js
     * ├── services
     * │   └── foo.js
     * ├── models
     * │   └── foo.js
     * ```
     *
     * You are in file `controllers/foo.js`
     *
     * ### Without alias
     * ```js
     * require('../services/foo')
     * require('../models/foo')
     * ```
     *
     * ### With alias
     * ```
     * ioc.alias(join(__dirname, 'app'), 'App')
     *
     * ioc.use('App/services/foo')
     * ioc.use('App/mdoels/foo')
     * ```
     */
    alias(directoryPath: string, alias: string): this;
    /**
     * A boolean telling if a fake exists for a binding or
     * not.
     */
    hasFake(namespace: string): boolean;
    /**
     * Returns a boolean telling if binding for a given namespace
     * exists or not.
     *
     * @example
     * ```js
     * ioc.hasBinding('Adonis/Src/View')
     * ```
     */
    hasBinding(namespace: string): boolean;
    /**
     * Returns a boolean telling if namespace is part of directory aliases or not.
     *
     * ### NOTE:
     * Check the following example carefully.
     *
     * @example
     * ```js
     * ioc.alias(join(__dirname, 'app'), 'App')
     * ioc.isAliasPath('App/Services/Foo')
     * ```
     */
    isAliasPath(namespace: string): boolean;
    /**
     * Returns the alias for a given namespace.
     *
     * @example
     * ```js
     * ioc.alias(join(__dirname, 'app'), 'App')
     *
     * ioc.getPathAlias('App/Services/Foo') // returns App
     * ioc.getPathAlias('Foo/Services/Foo') // returns undefined
     * ```
     */
    getPathAlias(namespace: string): string | undefined;
    /**
     * Clears the cache for directory aliasaes.
     *
     * - Cache for aliases if cleared when no alias is defined
     * - Optionally, the require cache can be cleared as well
     */
    clearAliasesCache(alias?: string, removeFromRequireCache?: boolean): void;
    /**
     * Lookup a namespace and return it's lookup node. The lookup node can speed
     * up resolving of namespaces via `use`, `useEsm` or `make` methods.
     */
    lookup(namespace: string, prefixNamespace?: string): null | any;
    /**
     * Use the binding by resolving it from the container. The resolve method
     * does some all the hard work to resolve the value for you.
     *
     * 1. The name will be searched for an existing binding.
     * 2. Checked against aliases directories.
     * 3. Finally an exception is raised when unable to perform lookup
     *
     * @example
     * ```js
     * ioc.use('Adonis/Src/View')     // binding
     * ioc.use('App/Services/User')   // Directory Alias
     * ```
     */
    use(namespace: string | LookupNode<any>): any;
    /**
     * Make an instance of class and auto inject it's dependencies. The instance
     * is only created if `namespace` is part of a directory alias or is a class
     * constructor.
     *
     * The bindings added via `ioc.bind` or `ioc.singleton` controls their return value
     * themselves using the factory function.
     */
    make<T extends any>(namespace: T | LookupNode<string>, args?: any[]): InferMakeType<T>;
    /**
     * Define a callback to be called when all of the container
     * bindings are available.
     */
    with(namespaces: readonly any[], cb: (...args: any) => void): void;
    /**
     * Call method on an object and inject dependencies to it automatically.
     */
    call<T extends object, K extends ExtractFunctions<T>>(target: T, method: K, args: any[]): any;
    /**
     * Restore a given fake
     */
    restore(namespace: string): void;
    /**
     * Define a custom trap for `ioc.use` and `ioc.make` calls
     */
    trap(callback: (namespace: string) => any): this;
    /**
     * Returns the resolver instance to resolve Ioc container bindings with
     * little ease. Since, the IocResolver uses an in-memory cache to
     * improve the lookup speed, we suggest keeping a reference to
     * the output of this method to leverage caching
     */
    getResolver(fallbackMethod?: string, rcNamespaceKey?: string, fallbackNamespace?: string): IocResolver;
}
