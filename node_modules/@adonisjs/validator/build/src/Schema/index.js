"use strict";
/*
 * @adonisjs/validator
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
const utils_1 = require("../utils");
/**
 * String schema type
 */
function string(options, rules) {
    return utils_1.getLiteralType('string', false, options, rules || []);
}
string.optional = function optionalString(options, rules) {
    return utils_1.getLiteralType('string', true, options, rules || []);
};
/**
 * Boolean schema type
 */
function boolean(rules) {
    return utils_1.getLiteralType('boolean', false, undefined, rules || []);
}
boolean.optional = function optionalBoolean(rules) {
    return utils_1.getLiteralType('boolean', true, undefined, rules || []);
};
/**
 * Number schema type
 */
function number(rules) {
    return utils_1.getLiteralType('number', false, undefined, rules || []);
}
number.optional = function optionalNumber(rules) {
    return utils_1.getLiteralType('number', true, undefined, rules || []);
};
/**
 * Date schema type
 */
function date(options, rules) {
    return utils_1.getLiteralType('date', false, options, rules || []);
}
date.optional = function optionalDate(options, rules) {
    return utils_1.getLiteralType('date', true, options, rules || []);
};
/**
 * Object schema type
 */
function object(rules) {
    return {
        members(schema) {
            return utils_1.getObjectType(false, Object.keys(schema).reduce((result, field) => {
                result[field] = schema[field].getTree();
                return result;
            }, {}), rules || []);
        },
        anyMembers() {
            return utils_1.getObjectType(false, null, rules || []);
        },
    };
}
object.optional = function optionalObject(rules) {
    return {
        members(schema) {
            return utils_1.getObjectType(true, Object.keys(schema).reduce((result, field) => {
                result[field] = schema[field].getTree();
                return result;
            }, {}), rules || []);
        },
        anyMembers() {
            return utils_1.getObjectType(true, null, rules || []);
        },
    };
};
/**
 * Array schema type
 */
function array(rules) {
    return {
        members(schema) {
            return utils_1.getArrayType(false, schema.getTree(), rules || []);
        },
        anyMembers() {
            return utils_1.getArrayType(false, null, rules || []);
        },
    };
}
array.optional = function optionalArray(rules) {
    return {
        members(schema) {
            return utils_1.getArrayType(true, schema.getTree(), rules || []);
        },
        anyMembers() {
            return utils_1.getArrayType(true, null, rules || []);
        },
    };
};
/**
 * Enum schema type
 */
function oneOf(enumOptions, rules) {
    return utils_1.getLiteralType('enum', false, enumOptions, rules || []);
}
oneOf.optional = function optionalEnum(enumOptions, rules) {
    return utils_1.getLiteralType('enum', true, enumOptions, rules || []);
};
/**
 * Enum set schema type
 */
function enumSet(enumOptions, rules) {
    return utils_1.getLiteralType('enumSet', false, enumOptions, rules || []);
}
enumSet.optional = function optionalEnumSet(enumOptions, rules) {
    return utils_1.getLiteralType('enumSet', true, enumOptions, rules || []);
};
/**
 * File schema type
 */
function file(options, rules) {
    return utils_1.getLiteralType('file', false, options, rules || []);
}
file.optional = function optionalFile(options, rules) {
    return utils_1.getLiteralType('file', true, options, rules || []);
};
/**
 * Define refs, which are resolved at runtime vs the compile time
 */
function refs(schemaRefs) {
    return Object.keys(schemaRefs).reduce((result, key) => {
        result[key] = {
            __$isRef: true,
            value: schemaRefs[key],
            key: key,
        };
        return result;
    }, {});
}
/**
 * List of available schema methods. One can add custom types by
 * using the extend method
 */
exports.schema = {
    string,
    boolean,
    number,
    date,
    object,
    array,
    enum: oneOf,
    enumSet: enumSet,
    file,
    refs,
    /**
     * Create a new schema compiled schema tree
     */
    create(tree) {
        return {
            props: {},
            tree: Object.keys(tree).reduce((result, field) => {
                result[field] = tree[field].getTree();
                return result;
            }, {}),
        };
    },
};
